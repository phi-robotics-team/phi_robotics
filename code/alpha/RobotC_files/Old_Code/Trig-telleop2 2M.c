#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     Gyro,           sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     ,               sensorI2CHiTechnicGyro)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     R_B,           tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     L_B,           tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     Arm,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//													 Tele-Operation Mode Code Template
//
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific                                    robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"	 //Include file to "handle" the Bluetooth messages.
task drive();
int deadband = 16;
//////////int gameend = 0;
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																		initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	nMotorPIDSpeedCtrl[R_B]= mtrSpeedReg;
	nMotorPIDSpeedCtrl[L_B]= mtrSpeedReg;
	nMaxRegulatedSpeed12V = 1000;

	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																				 Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//	 1. Loop forever repeating the following actions:
//	 2. Get the latest game controller / joystick settings that have been received from the PC.
//	 3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//			simple action:
//			*	 Joystick values are usually directly translated into power levels for a motor or
//				 position of a servo.
//			*	 Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//				 position.
//	 4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	bFloatDuringInactiveMotorPWM = false;
	nxtDisplayTextLine(2, "Waiting for start");
	waitForStart();		// wait for start of tele-op phase
	nxtDisplayTextLine(2, "starting");
	StartTask( drive );

	float watchedmessage;
	//int watch = 1;
	while(true)
	{
		watchedmessage = ntotalMessageCount; // grabs the number of Messages and names it watchedMessage

		wait10Msec(25); // give the Messagecount time to change it changes every 50ms

		if(watchedmessage == ntotalMessageCount) // checks to see if the Message change if has not it is Disconnected
		{                // if Disconnected it runs this
			motor[mtr_S1_C1_1] = 0; // stops motor
			motor[mtr_S1_C1_2] = 0;
			motor[mtr_S1_C2_1] = 0;
			motor[mtr_S1_C2_2] = 0;
			motor[mtr_S1_C3_1] = 0;
			motor[mtr_S1_C3_2] = 0;
			motor[mtr_S1_C4_1] = 0;
			motor[mtr_S1_C4_2] = 0;


			StopTask(drive);

			wait1Msec(10); //gives time to spot

			StartTask(drive);

			nxtDisplayTextLine(2, "DISCONNECTED"); //displays DISCONNECTED to tell you if you are Disconnected
		}
		else//if the Message change you are connected
		{

			 nxtDisplayTextLine(2, "CONNECTED");//displays CONNECTED to tell you if everything is working

		}
	}

}

task drive()
{
	int Heading;
	int Magnatude;
	int MoveX;
	int MoveY;
	int oldDirection;
	int newDirection;
	int deadband = 10;

	/*This teleop will take the values of the joystick on the graph and convert it to polar notation for movement.
	 * The degree value will tell the robot where to turn and the magnatude will give the robot the power at which it
	 * needs to move forwards*/

	while (true)
	{

		getJoystickSettings(joystick); //Gets value from the joystick

		 oldDirection = SensorValue[Gyro];

		 MoveX = joystick.joy1_x1; //Sets X value and Y value to the variables
		 MoveY = joystick.joy1_y1;

	 	 Magnatude = sqrt(MoveX^2 + MoveY^2); //Use pythagorean theorum to caluculate net magnatude of movement

		 Heading = atan(MoveY/MoveX) * sgn(MoveX);//Finds the value for the degrees the robot needs to turn.

		 if (Heading < deadband)
		 {
		   Heading = 0;
		 }


		 while (SensorValue[Gyro] != Heading +- deadband/4)
		 {
		   motor[L_B] = sgn(MoveX) * Magnatude;
		   motor[R_B] = sgn(MoveX) * -Magnatude;
	   }

	   while (SensorValue[Gyro] == Heading +- deadband/4)
	   {
	   	 motor[L_B] = Magnatude;
		   motor[R_B] = Magnatude;
	   }


   }
}
