package com.qualcomm.ftcrobotcontroller.opmodes;

import com.qualcomm.ftccommon.DbgLog;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorController;
import com.qualcomm.robotcore.hardware.GyroSensor;

/**
 * Created by phi on 11/19/2015.
 */

public class base_autonomy_13 extends LinearOpMode {

    DcMotor leftFront;
    DcMotor leftRear;
    DcMotor rightFront;
    DcMotor rightRear;
    DcMotorController dc_1;
    DcMotorController dc_2;
    GyroSensor gyro;
    DcMotorController.DeviceMode devMode_a;
    DcMotorController.DeviceMode devMode_b;

    int rotDirection;
    int state = 0;

    // wheel and motor info to calculate the # of counts on encoder per inch of distance 'cnts_distin'
    double diam = 4.0;
    long cnts_motorrev = 1440;
    //long cnts_motorrev = 1120;
    double dist_wheelrev = 3.1416 * diam;
    double motorrev_wheelrev = 1.0;
    double cnts_distin = cnts_motorrev * motorrev_wheelrev / dist_wheelrev;


    @Override
    public void runOpMode() throws InterruptedException {
        gyro = hardwareMap.gyroSensor.get("gyro");
        rightFront = hardwareMap.dcMotor.get("rightFront");
        rightRear = hardwareMap.dcMotor.get("rightRear");
        leftFront = hardwareMap.dcMotor.get("leftFront");
        leftRear = hardwareMap.dcMotor.get("leftRear");
        dc_1 = hardwareMap.dcMotorController.get("dc_1");
        dc_2 = hardwareMap.dcMotorController.get("dc_2");


        leftFront.setDirection(DcMotor.Direction.REVERSE);
        leftRear.setDirection(DcMotor.Direction.REVERSE);


        // wait for the start button to be pressed.
        waitForStart();

        double reqTurnDegrees;
        double power;
        double dist;

        leftFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
        rightFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
        //leftFront.setChannelMode(DcMotorController.RunMode.RUN_TO_POSITION);
        //rightFront.setChannelMode(DcMotorController.RunMode.RUN_TO_POSITION);
        telemetry.addData("dc_runmode", dc_1.getMotorControllerDeviceMode());

        //time.startTime();
        while (opModeIsActive()) {

//tc:  this is setup so that each action by the robot(turn, move, move a servo) is a case which is
//tc:  sequenced through by updating the 'state' variable by 1.  
            switch (state) {
                case 0:
                    //devMode_a = DcMotorController.DeviceMode.WRITE_ONLY;
                    //devMode_b = DcMotorController.DeviceMode.WRITE_ONLY;
                    dist = 14.0;
                    power = 1.0;
                    MoveEncoder(dist, power);
                    telemetry.addData("state", state);
                    state = state + 1;
                    wait1Msec(200);
                case 1:
                    reqTurnDegrees = 90;
                    Turn(reqTurnDegrees);
                    telemetry.addData("state", state);
                    state = state + 1;
                    //  leftFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
                    //  rightFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
                    wait1Msec(200);
                case 2:
                    // devMode_a = DcMotorController.DeviceMode.WRITE_ONLY;
                    // devMode_b = DcMotorController.DeviceMode.WRITE_ONLY;
                    dist = 10.0;
                    power = 1.0;
                    MoveEncoder(dist, power);
                    //  leftFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
                    //  rightFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
                    state = state + 1;
                    telemetry.addData("state", state);
                    wait1Msec(200);
                case 3:
                    reqTurnDegrees = -45;
                    Turn(reqTurnDegrees);
                    state = state + 1;
                    telemetry.addData("state", state);
                    wait1Msec(200);
                case 4:
                    //devMode_a = DcMotorController.DeviceMode.WRITE_ONLY;
                    //devMode_b = DcMotorController.DeviceMode.WRITE_ONLY;
                    dist = -12.0;
                    power = 1.0;
                    MoveEncoder(dist, power);
                    //  leftFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
                    //  rightFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
                    state = state + 1;
                    telemetry.addData("state", state);
                    wait1Msec(200);
                default:
                    dc_1.setMotorControllerDeviceMode(DcMotorController.DeviceMode.READ_ONLY);
                    dc_2.setMotorControllerDeviceMode(DcMotorController.DeviceMode.READ_ONLY);
                    wait1Msec(20);
                    telemetry.addData("default", "default");
                    telemetry.addData("left front curr enc",leftFront.getCurrentPosition());
                    telemetry.addData("getTargetPosn_LF", leftFront.getTargetPosition());
                    wait1Msec(5000);
            }

            waitOneFullHardwareCycle();

        }
    }


    //Gets the bias for the gyro
    double getBias() {
        return gyro.getRotation();
    }


    // Executes the gyro turn
    void Turn(double turnDegrees) throws InterruptedException {
        double Angle = 0.0;
        double t1 = this.time;
        double time_old = 0.0;
        double GyroOld = 0.0;
        double maxVelocity = 180.0;
        double motorSpeed = 0.5;
        double DegreeGain = 1.0;
        double MAX_GYRO_SPEED = .85; //maximum motor speed allowed in turns
        double MIN_GYRO_SPEED = .40; //minimum motor speed allowed in turns

	   // tc:  also may make code cleaner and easier to follow to eliminate the call to 'executeturn' and put the code in it here
        executeTurn(turnDegrees, Angle, t1, time_old, GyroOld, maxVelocity, motorSpeed, DegreeGain, MAX_GYRO_SPEED, MIN_GYRO_SPEED);

		//  tc:  may want to move after while-loop in 'execute turn', but it should not matter...
        // since we have now reached the target rotation (the while loop is done), stop all drive motors
        motorSpeed = 0.0;
        leftRear.setPower(motorSpeed);
        leftFront.setPower(motorSpeed);
        rightRear.setPower(motorSpeed);
        rightFront.setPower(motorSpeed);


    }

    void executeTurn(double turnDegrees, double Angle, double t1, double time_old, double GyroOld, double maxVelocity, double motorSpeed, double DegreeGain, double MAX_GYRO_SPEED, double MIN_GYRO_SPEED) throws InterruptedException {
        double delta_time;
        double time100 = 0.;
        double GyroNew;
        double degreesToGo;
        long rotDirection;
        //int ii;
        //int ns = 20;
        // double gyroBias;
        // double gyroBias_sum=0.;
        double gyroBias = getBias();
        // tc: may want to average the gyro bias over a few frames instead of just the first value
        //for (ii=1; ii==ns; ii++) {
        //gyroBias = getBias();
        //    gyroBias_sum=gyroBias + gyroBias_sum;
        // }
        //gyroBias=gyroBias_sum/ns;


        if (turnDegrees < 0) rotDirection = -1;
        else rotDirection = 1;

        //Runs motors at very low power to stop backlash
        motorSpeed = .05;
        leftRear.setPower(rotDirection * motorSpeed);
        leftFront.setPower(rotDirection * motorSpeed);
        rightRear.setPower(-rotDirection * motorSpeed);
        rightFront.setPower(-rotDirection * motorSpeed);
//tc:  All through the code there are these 'wait' statements which pause the code to make sure the commands
//tc:  to the motor get executed before it goes on. 10 msecs below comes from the C-code.  Each frame on
//tc:  this system tends to take 10-12 msecs.  Should make these 'wait' statements at least 20 msecs.  
//tc:  You don't want them to large because then the program will take longer to execute, and you have
//tc:   only so much time.  Generally, we  need to use a number like 20-50 msecs and if it works then could
//tc:   try to reduce it.  
        wait1Msec(10);


        //set first time_old to be current time.  Since delta_time tends to be 10-12 millisecs.  The wait1Msec(10) is appropriate
        time_old = t1;


//tc:   This is the guts of the gyro turn.  As long as the difference between the angle that is
//tc:   commanded,'turnDegrees', and the current angle the robot has rotated,'Angle', is > 3, it continues
//tc:   to power the turn.  You don't want the 3 to be a 0 because if you do it will overrotate. Turning
//tc:   the motors off doesn't happen instantaneously.
        while ((Math.abs(turnDegrees) - Math.abs(Angle)) > 3) {

            // read the gyro sensor minus the bias offset. GyroBias must be declared and
            // computed in the calling program.
            GyroNew = -(gyro.getRotation() - gyroBias);

            // this timer wraps around
            t1 = this.time;
            time = t1;
            delta_time = Math.abs(time - time_old); // delta time in s


            // since the 'delta_time' is in secs changed the '1' to '.001'
            if (delta_time < .001) // protect against divide by zero
            {
                delta_time = .001;
            }


            // limit the gyro to the max achievable by the bot to minimize data spikes.
            if (Math.abs(GyroNew) > maxVelocity) GyroNew = Math.signum(GyroNew) * maxVelocity;

            // deadband for the gyro to eliminate drift due to noise
            if (Math.abs(GyroNew) <= 0.2) GyroNew = 0.0;

            // compute the integral of the angular rate using a trapazoidal approximation
            // http://en.wikipedia.org/wiki/Numerical_integration

            //tc: since the 'delta_time' is in secs already took out the .001* in c code
            Angle = Angle + delta_time * 0.5 * (GyroNew + GyroOld);


            // update the old values for the next time through the loop
            time_old = time;
            GyroOld = GyroNew;

            // Calculate the rotation remaining
            degreesToGo = Math.abs(turnDegrees) - Math.abs(Angle);

		    //tc:  with time we should look to implement something like this in the move function as well...
            // motor speed is proportional to the amount of rotation remaining
            motorSpeed = (DegreeGain * Math.abs(degreesToGo));

            // limit the motor speed to be greater than .40 and less than .85
            if (Math.abs(motorSpeed) > MAX_GYRO_SPEED) motorSpeed = MAX_GYRO_SPEED;
            if (Math.abs(motorSpeed) < MIN_GYRO_SPEED) motorSpeed = MIN_GYRO_SPEED;


            leftRear.setPower(rotDirection * motorSpeed);
            leftFront.setPower(rotDirection * motorSpeed);
            rightRear.setPower(-rotDirection * motorSpeed);
            rightFront.setPower(-rotDirection * motorSpeed); // side moves forward for (+) CW rotation\

            //tc: modified so that the 'time100' is incremented every frame
            time100 = delta_time + time100;

		//tc:  again, delay necessary to make sure motors can execute the command before
		//tc: moving on.
            wait1Msec(20); // wait 20 ms to allow a reasonable period for the integration

		//tc:  may want to reduce this # to 5.0, as it was in original c code.
            if (time100 > 10.0) break; // if the bot is not done turning in 5 sec, quit

        }  // end while loop

    }

    void MoveEncoder(double dist, double power) throws InterruptedException {
        double leftFrontCurrentEncoder = 0;
        double rightFrontCurrentEncoder = 0;
        double t1;

//tc this is a variable which pauses the execution at certain times.  May want to reduce this down
//tc:  to the lowest # which produces satisfacory results.
        long tdly=50;

//tc:  once the move function can be shown to work,  uncomment this on the backlash.  It should
//tc: help improve accuracy.  I'd change the 10msec pause to be 20 at best.  May not be
        //Runs motors at very low power to stop backlash
     /*   leftRear.setPower(.05);
        leftFront.setPower(.05);
        rightRear.setPower(.05);
        rightFront.setPower(.05);
        wait1Msec(10);
//Runs motors at very low power to stop backlash
        leftRear.setPower(.0);
        leftFront.setPower(.0);
        rightRear.setPower(.0);
        rightFront.setPower(.0);
        wait1Msec(10); */

//tc:  Reseting the encoders allows the current position of the shaft to be read as zero.  This makes it easier
//tc:  for us to determine the relative rotation of the shaft.  For the test robot we only had encoders
//tc:  on the two front wheels.

        leftFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
        rightFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
        wait1Msec(tdly);

//tc:  There are three motor controller modes you can use:  
//tc:   'run_using_encoders', 'run_to_position', and 'run_without_encoders'.  
//tc:   'run_using_encoders' will run the motors at a constant speed no matter what power
//tc:   setting you give it, I believe.
//tc:   'run_without_encoders' runs at the power setting you give it. The motor load vs. power
//tc:     setting is not linear, which may or may not be an issue.  But you can vary the power
//tc:     and therefore speed.
//tc:   'run_to_position' requires you to give the encodered motors a target postion.  They will
//tc:     automatically spin the motors until that encoder count is obtained without you having
//tc:     to do anything else.  Disadvantage here is that the motor output is limited to 65% of
//tc:     it's max value, or so I read. Did not prove that yet with data.
 
//tc:  this is how you change the motor controller mode.  Probably could delete the first 'wait'
        leftFront.setChannelMode(DcMotorController.RunMode.RUN_USING_ENCODERS);
        rightFront.setChannelMode(DcMotorController.RunMode.RUN_USING_ENCODERS);
        wait1Msec(tdly);
        leftRear.setChannelMode(DcMotorController.RunMode.RUN_USING_ENCODERS);
        rightRear.setChannelMode(DcMotorController.RunMode.RUN_USING_ENCODERS);
        wait1Msec(tdly);

//tc:  lots of comment and telemetry and unused code and telemetry and DbgLog statements in this
//tc:   whole thing that can be cleaned up.
        //leftFront.setChannelMode(DcMotorController.RunMode.RUN_TO_POSITION);
        //rightFront.setChannelMode(DcMotorController.RunMode.RUN_TO_POSITION);
        // wait1Msec(20);

        // devMode_a = dc_1.getMotorControllerDeviceMode();
        // devMode_b = dc_2.getMotorControllerDeviceMode();
        // wait1Msec(20);

//tc:  this line figures how the encoder count target is generated
        double cnt_target = cnts_distin * dist;
        //  telemetry.addData("cnt_target", (int) cnt_target);
        // telemetry.addData("ii", ii);

//tc:   this is how you set the encoder target position of using 'run_to_position' mode. On
//tc:   the test robot we only had the two front wheels with encoders.  Thus these are the only
//tc:   two worth setting targets for.  
//tc:   Note: current setup uses 'run_using_encoder' mode, not 'run_to_position'.  So I don't
//tc:    these two commands are being used.
        leftFront.setTargetPosition((int) cnt_target);
        rightFront.setTargetPosition((int) cnt_target);

        // leftRear.setTargetPosition((int) cnt_target);
        // rightRear.setTargetPosition((int) cnt_target);

//tc:  if 'dist' passed is < 0, then the robot moves backward by changing the sign of 'power'
//tc:  sent to the motors. 
        if (dist < 0) power = -power;

        //  telemetry.addData("left device mode", devMode_a);
        // telemetry.addData("right device mode", devMode_b);

//tc:  this 'if' statement was inserted to troubleshoot why it would not move backwards properly.
//tc:  I think we can delete it.  But the comments inserted illustrate different things worth
//tc:  noting.

        if (dist < 0) {

//tc:  disadvantage of using the old motor controllers is that you can either write to the motors,
//tc: or read from the motors.  You can't do both. So the motor controller defaults to 'write'
//tc: mode.  To read the encoders you have to first change the mode to 'read_only'.  Then you
//tc: can read the encoder.  When done, you must put it back to 'write_only' before you try
//tc:  to send a power command to the motor, or else the code will rebel against you and kill the robot.

            dc_1.setMotorControllerDeviceMode(DcMotorController.DeviceMode.READ_ONLY);
            dc_2.setMotorControllerDeviceMode(DcMotorController.DeviceMode.READ_ONLY);
            wait1Msec(tdly);
            telemetry.addData("dist less 0","dist less 0");
            telemetry.addData("power", power);
            telemetry.addData("cnt_target",cnt_target);
            telemetry.addData("left front curr enc", leftFrontCurrentEncoder);
            // telemetry.addData("getTargetPosn_LF", leftFront.getTargetPosition());


//tc:  where the 'telemetry' statement causes stuff to print to phone,  the 'dbglog' statement
//tc:   will write it to a file.  You can copy the file to your laptop,  or you can watch
//tc:   the data from studio on the lower left window after you plug the phone into the laptop.
//tc:   Often, alas,  something kills the phone and prevents it from happening though.
            DbgLog.msg(String.format("Data3-leftFront.getPower- %.03f", (float) leftFront.getPower()));
            DbgLog.msg(String.format("Data3-TargetPosn - %.03f", (float) cnt_target));
            DbgLog.msg(String.format("Data3-LeftFrontEncoder- %.03f", (float) leftFrontCurrentEncoder));
            dc_1.setMotorControllerDeviceMode(DcMotorController.DeviceMode.WRITE_ONLY);
            dc_2.setMotorControllerDeviceMode(DcMotorController.DeviceMode.WRITE_ONLY);

//tc:  this was tossed in to read the stuff being printed to the phone.  
            wait1Msec(8000);
        }
        telemetry.addData("power", power);

//tc:   here is where the power gets sent to the motors...
        leftFront.setPower(power);
        rightFront.setPower(power);
        leftRear.setPower(power);
        rightRear.setPower(power);
        wait1Msec(tdly);


        //wait1Msec(200);

        dc_1.setMotorControllerDeviceMode(DcMotorController.DeviceMode.READ_ONLY);
        dc_2.setMotorControllerDeviceMode(DcMotorController.DeviceMode.READ_ONLY);
        wait1Msec(tdly);

      /*  telemetry.addData("leftFront Power", leftFront.getPower());
        telemetry.addData("rightFront power", rightFront.getPower());
        telemetry.addData("leftRear Power", leftRear.getPower());
        telemetry.addData("rightRear power", rightRear.getPower());*/

       /* telemetry.addData("right front curr enc", rightFrontCurrentEncoder);
        telemetry.addData("getTargetPosn_RF",rightFront.getTargetPosition());
        telemetry.addData("left front curr enc", leftFrontCurrentEncoder);
        telemetry.addData("getTargetPosn_LF",leftFront.getTargetPosition()); */


//tc:  this is the guts of the move function,  if sensor encoder counts read < target, keep on
//tc:   spinning the wheels.  Normally if we have two encoders both will be checked ('&&' means 'and').
//tc:   But, in the test robot we found only the left worked.  This is why it is commented out here
//tc:   and replaced in the following line by just the left encoder.  Not the difference in the use
//tc:   of 'abs'.  This must be included for it to work properly.

        //  while (rightFrontCurrentEncoder < cnt_target && leftFrontCurrentEncoder < cnt_target) {

//tc:  absolutes here ensure that the negative distance commanded works. For robot moving backwards
//tc:   the 'cnt_target' will be a negative #.
//tc:  Basically as the motor
//tc:   spins the wheels backwards the encoder counts being sensed will go from 0 to more negative.
//tc:   Thus, without the absolute, 'abs', the first frame will show that the 'leftFrontCurrentEncoder'
//tc:      is 0 and will not be less than the 'cnt_target'.  Thus the statement is 'false', and the
//tc:   whole move is skipped.  
        while ( Math.abs(leftFrontCurrentEncoder) < Math.abs(cnt_target)) {

            t1 = this.time;

            // If we've switched to read mode, we can read data from the NXT device.
            // Only necessary on NXT devices.

            // Update the reads after some loops, when the command has successfully propagated through.
            telemetry.addData("leftFront Power", leftFront.getPower());
            telemetry.addData("rightFront power", rightFront.getPower());
            telemetry.addData("leftRear Power", leftRear.getPower());
            telemetry.addData("rightRear power", rightRear.getPower());

            //  telemetry.addData("left device mode", devMode_a);
            //  telemetry.addData("right device mode", devMode_b);

		/tc:  right here we read the encoder sensor value...
            rightFrontCurrentEncoder = rightFront.getCurrentPosition();
            leftFrontCurrentEncoder = leftFront.getCurrentPosition();

            // rightRearCurrentEncoder = rightRear.getCurrentPosition();
            // leftRearCurrentEncoder = leftRear.getCurrentPosition();

            telemetry.addData("right front curr enc", rightFrontCurrentEncoder);
            //  telemetry.addData("getTargetPosn_RF", rightFront.getTargetPosition());
            telemetry.addData("cnt_target", cnt_target);
            telemetry.addData("left front curr enc", leftFrontCurrentEncoder);
            telemetry.addData("getTargetPosn_LF", leftFront.getTargetPosition());
            wait1Msec(tdly);
            DbgLog.msg(String.format("Data2-Time- %.03f", t1));
            DbgLog.msg(String.format("Data2-RightFrontEncoder- %.03f", (float) rightFrontCurrentEncoder));
            DbgLog.msg(String.format("Data2-leftFront.getPower- %.03f", (float) leftFront.getPower()));
            DbgLog.msg(String.format("getTargetPosn_LF - %.03f", (float) leftFront.getTargetPosition()));
            DbgLog.msg(String.format("Data2-LeftFrontEncoder- %.03f", (float) leftFrontCurrentEncoder));

            //wait1Msec(2000);
            // Only needed on Nxt devices, but not on USB devices

        }

//tc:  when done with the move go back to 'write' mode and turn the motors off...
        dc_1.setMotorControllerDeviceMode(DcMotorController.DeviceMode.WRITE_ONLY);
        dc_2.setMotorControllerDeviceMode(DcMotorController.DeviceMode.WRITE_ONLY);
        wait1Msec(tdly);
        telemetry.addData("inside loop", "yes");
        leftFront.setPower(0.0);
        rightFront.setPower(0.0);
        rightRear.setPower(0.0);
        leftRear.setPower(0.0);
        wait1Msec(tdly);

//tc: again probably do not need the first 'wait'...
        leftFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
        rightFront.setChannelMode(DcMotorController.RunMode.RESET_ENCODERS);
        wait1Msec(tdly);
        leftFront.setChannelMode(DcMotorController.RunMode.RUN_WITHOUT_ENCODERS);
        rightFront.setChannelMode(DcMotorController.RunMode.RUN_WITHOUT_ENCODERS);
        wait1Msec(tdly);
        leftRear.setChannelMode(DcMotorController.RunMode.RUN_WITHOUT_ENCODERS);
        rightRear.setChannelMode(DcMotorController.RunMode.RUN_WITHOUT_ENCODERS);
    }

    private boolean withinMarginOfError(int goal, int value) {
        int lowerMargin = goal - 5;
        int upperMargin = goal + 5;
        return (value >= lowerMargin && value <= upperMargin);
    }

    //Waits 1t milliseconds
    void wait1Msec(long time) throws InterruptedException {
        Thread.sleep(time);
        return;
    }
}

