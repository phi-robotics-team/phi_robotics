#pragma config(Hubs,	S1, HTMotor,	HTMotor,	HTMotor,	HTServo)
#pragma config(Sensor, S1,		 ,							 sensorI2CMuxController)
#pragma config(Sensor, S2,		 Gyro,					 sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,		 IR,						 sensorHiTechnicIRSeeker600)
#pragma config(Sensor, S4,		 sonar,					 sensorNone)
#pragma config(Motor,	 mtr_S1_C1_1,			B_R,					 tmotorTetrix, openLoop, encoder)
#pragma config(Motor,	 mtr_S1_C1_2,			B_L,					 tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,	 mtr_S1_C2_1,			block_arm,		 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S1_C2_2,			Flag_Arm,			 tmotorTetrix, openLoop, reversed)
#pragma config(Motor,	 mtr_S1_C3_1,			motorH,				 tmotorTetrix, openLoop)
#pragma config(Motor,	 mtr_S1_C3_2,			Winch,				 tmotorTetrix, openLoop, reversed)
#pragma config(Servo,	 srvo_S1_C4_1,		Hook,									tServoStandard)
#pragma config(Servo,	 srvo_S1_C4_2,		Claw,									tServoStandard)
#pragma config(Servo,	 srvo_S1_C4_3,		IR_turret,						tServoStandard)
#pragma config(Servo,	 srvo_S1_C4_4,		servo4,								tServoNone)
#pragma config(Servo,	 srvo_S1_C4_5,		servo5,								tServoNone)
#pragma config(Servo,	 srvo_S1_C4_6,		servo6,								tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

float GyroBias = 0; //Used to calibrate the current gyro position
int avgdata = 0; //Used to measure the current gyro position
int moveRunning = 0; //Defines whether or not the Move() function is running
bool auto_waiting = true;
int IR_position = 1;
int IR_Beacon = 0;

int pos1 = 100; // this is the estimated servo cmd to put the beam of region 6 onto IR position 1
int pos2 = 120;// this is the estimated servo cmd to put the beam of region 6 onto IR position 2
int pos3 = 130;// this is the estimated servo cmd to put the beam of region 6 onto IR position 3
int pos4 = 137;// this is the estimated servo cmd to put the beam of region 6 onto IR position 4

//#include "JoystickDriver.c" //Include file to "handle" the Bluetooth messages.

task Find_IR(); //Defines the FIND_IR task
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																		initializeRobot
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	servo[Claw] = 110; //Sets Claw to closed position
	servo[Hook] = 127; //Sets Hook to starting position

	bFloatDuringInactiveMotorPWM = false;

	motor(B_L) = 0; //Sets left drive motors to 0
	motor(B_R) = 0; //Sets right drive motors to 0

	StartTask( Find_IR ); // start the Find_IR task
	auto_waiting = true;

	for (int i = 0; i < 20; i++)
	{
		avgdata += SensorValue[Gyro]; //Takes 20 measurements of the gyro
		wait1Msec(25); //Pauses for 250 miliseconds
	}

}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//																				 Main Task
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot(); //Executes all code in the initializeRobot() function

	// waitForStart(); //Wait for the beginning of autonomous phase
	while(true)
	{
		nxtDisplayBigTextLine(3, "IR_position: %4d", IR_position);
		if (abs(IR_position - pos1) < 4)
		{
			IR_Beacon = 1;
		}
		else if (abs(IR_position - pos2) < 4)
		{
			IR_Beacon = 2;
		}
		else if (abs(IR_position - pos3) < 4)
		{
			IR_Beacon = 3;
		}
		else if (abs(IR_position - pos4) < 4)
		{
			IR_Beacon = 4;
		}
		nxtDisplayBigTextLine(4, "IR_Beacon: %4d", IR_Beacon);
	}
	auto_waiting = false;

	StopTask(Find_IR);
}

task Find_IR()
{
	// this task will rotate the "beam" of the IR sensor to try and locate the IR beacon
	// variables auto_waiting and IR_position need to be declared in the main program
	// auto_waiting is a boolean, and is true if the autonomous program has not gotten past the
	// wait for start

	int max6 = 0;
	int min6 = 255;
	int ave6 = 0;
	int max4 = 0;
	int min4 = 255;
	int ave4 = 0;
	int IR_value = 0;

	while (auto_waiting) // while the autonomous mode is not running
	{
		max6 = 0; // initialize the min and max
		min6 = 255;
		max4 = 0;
		min4 = 255;

		IR_value = SensorValue[IR]; // read the IR sensor
		if (IR_value > 2 && IR_value < 8) // if IR is found forward of sensor
		{
			servo[IR_turret] = 10; // Rotate servo CCW to start
			wait10Msec(50); //Pause for 500 miliseconds waiting for servo to finish moving

			while(SensorValue[IR] > 3 && ServoValue[IR_turret]< 245) // while the IR sensor is > 3
			{
				servo[IR_turret] = ServoValue[IR_turret] + 2; // Rotate servo CW
				wait1Msec(25); //Pause for 25 miliseconds to allow the servo to move
				if (SensorValue[IR] == 6) // if the IR is in the beam at sector 6
				{
					if (ServoValue[IR_turret] > max6)
					{
						max6 = ServoValue[IR_turret];
					}
					if (ServoValue[IR_turret] < min6)
					{
						min6 = ServoValue[IR_turret];
					}
				}	 // end if
				if (IR_value == 4) // if the IR is in the beam at sector 4
				{
					if (ServoValue[IR_turret] > max4)
					{
						max4 = ServoValue[IR_turret];
					}
					if (ServoValue[IR_turret] < min4)
					{
						min4 = ServoValue[IR_turret];
					}
				} // end if
			} // end while
			ave6 = (max6 + min6)/2; // find the midpoint of the beams
			ave4 = (max4 + min4)/2;
			IR_position = ave6;
			nxtDisplayBigTextLine(1, "min6: %4d", min6);
			nxtDisplayBigTextLine(2, "max6: %4d", max6);

		}
	}
}
