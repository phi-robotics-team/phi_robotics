#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S2,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     B_L,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     B_R,           tmotorTetrix, PIDControl, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
float GyroBias = 0;
int avgdata = 0;
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.nclude "Move.c"
//#include "arm2.c"
//#include "Turn_Gyro.c"
//#include "move2.5_452.c"

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////


void initializeRobot()
{
int nDelay = 200;

	bFloatDuringInactiveMotorPWM = false;

	motor(B_L) = 0;
	motor(B_R) = 0;

	 for (int i = 0; i < 20; i++) {
    avgdata += SensorValue[Gyro];
    wait1Msec(25);}
	}



	void Move( float distance, float max_speed )
{
		nMotorPIDSpeedCtrl[B_L]= mtrSpeedReg;
		nMotorPIDSpeedCtrl[B_R]= mtrSpeedReg;
	nMaxRegulatedSpeed12V = 1000;
  float COUNTS_PER_INCH = 22.85;//slightly off. need recalibration
  int countDistance;
  int direction = 1;
  int motorSpeed = 0;
  int MAX_ENCODER_SPEED  = 50;
  int cut = 3;
	float Sum_left;
	float Sum_right;
	float RestofDst = 0.75;

  // Determine direction. Set to negative for backwards
  if( distance < 0 )
  {
    direction = -1;
  }
  if( distance <= 5 )
  {
  	motorSpeed = MAX_ENCODER_SPEED/cut;
  }
  // Calculate the distance to travel in encoder counts
  countDistance = abs(distance) * COUNTS_PER_INCH;

  // remove the backlash and freeplay from the motors before zeroing the encoders by commanding
  // a very low power for a short time

  motorSpeed = 5;
  motor[B_L] = direction * motorSpeed;
  motor[B_R] = direction * motorSpeed;
  wait1Msec(10);

  if ( (int)(abs(max_speed)) < MAX_ENCODER_SPEED)
  	{
  		MAX_ENCODER_SPEED = (int)max_speed;
    }

  // reset the motor encoders to zero
  nMotorEncoder[B_L] = 0;
  nMotorEncoder[B_R] = 0;
//  nMotorEncoderTarget[F_L] = countDistance;
 // nMotorEncoderTarget[F_R] = countDistance;

  motor[B_L] = direction * MAX_ENCODER_SPEED;
  motor[B_R] = direction * MAX_ENCODER_SPEED;

  while (abs(nMotorEncoder[B_L])<  countDistance && abs(nMotorEncoder[B_R])<  countDistance)
  { //while the encoder value is less than the distance it needs to reach
    wait10Msec(25);
    Sum_left = (abs(nMotorEncoder[B_L])); //Ads up the encodr values on the left and right to compare them
    Sum_right = (abs(nMotorEncoder[B_R]));

    /*if (Sum_left > Sum_right)
    {
    	motor[F_R] = direction * MAX_ENCODER_SPEED + 5;
    	motor[B_R] = direction * MAX_ENCODER_SPEED + 5;
  }
    	else if (Sum_left < Sum_right)
    	{
    		motor[F_L] = direction * MAX_ENCODER_SPEED + 5;
    		motor[B_L] = direction * MAX_ENCODER_SPEED + 5;
  }*/
    if (abs(nMotorEncoder[B_L]) >= countDistance * RestofDst && abs(nMotorEncoder[B_R]) >=  countDistance * RestofDst)
    { //If the encoder values becomes greater than a certain percentage of the total value needed to reach the desired distance.
        motor[B_L] = MAX_ENCODER_SPEED/cut; //the motor value will continue to be cut until the distance is reached.
  	  	motor[B_R] = MAX_ENCODER_SPEED/cut;
    }


   }

  motor[B_L] = -direction*20;
  motor[B_R] = -direction*20;

  wait10Msec(10);

  motor[B_L] = 0;
  motor[B_R] = 0;

  // reset the back motor encoders to zero
  nMotorEncoder[B_L] = 0;
  nMotorEncoder[B_R] = 0;

} // End of Move()

	void Turn( float turnDegrees )
{
	// Store new bias
  GyroBias = ((float)avgdata / 20);
	int state = 2;
  int time;
  int time_old = 0;
  int delta_time;
  float maxVelocity = 180.0; // max angular velocity in deg/sec
  float GyroOld;
  float GyroNew;
  int rotDirection = 1;
  int motorSpeed = 0;
  float DegreeGain = 5.0;
  float degreesToGo;
  int MAX_GYRO_SPEED  = 85; //maximum motor speed allowed in turns
  int MIN_GYRO_SPEED  = 40; //minimum motor speed allowed in turns
  float Angle;

  // Determine the rotation direction. Set to negative for clock-wise rotation.
  if( turnDegrees < 0 ) rotDirection = -1;

  // Set the Angle and components to zero befor turning
  Angle = 0.0;
  degreesToGo = 0.0;
  time_old = nPgmTime;
  GyroOld = 0.0;
  wait1Msec(100);

  // remove the backlash and freeplay from the motors before zeroing the encoders by commanding
  // a very low power for a short time

  motorSpeed = 5;
  motor[B_L] = -rotDirection * motorSpeed;
  motor[B_R] = rotDirection * motorSpeed;
  wait1Msec(10);

  // reset the back motor encoders to zero
  nMotorEncoder[B_R] = 0;
  nMotorEncoder[B_L] = 0;

  ClearTimer(T3);
  //---------------------------------------------------------------------------
  // Move the motors until the gyro Angle indicates the rotation is complete
  //---------------------------------------------------------------------------
  while( ( abs(turnDegrees) - abs(Angle) ) > 3 )
  {
    time =  nPgmTime; // this timer wraps around
    delta_time = abs(time - time_old); // delta time in ms

    if (delta_time < 1) // protect against divide by zero
    {
      delta_time = 1;
    }
    // read the gyro sensor minus the bias offset. GyroBias must be declared and
    // computed in the calling program.
    GyroNew = -((float)SensorValue[Gyro] - GyroBias);

    // limit the gyro to the max achievable by the bot to minimize data spikes.
    if (abs(GyroNew) > maxVelocity) GyroNew = sgn(GyroNew)*maxVelocity;

    // deadband for the gyro to eliminate drift due to noise
    if (abs(GyroNew) <= 0.2) GyroNew = 0.0;

    // compute the integral of the angular rate using a trapazoidal approximation
    // http://en.wikipedia.org/wiki/Numerical_integration
    Angle = Angle + 0.001 * (float)delta_time * 0.5 *(GyroNew + GyroOld);

    // update the old values for the next time through the loop
    time_old = time;
    GyroOld = GyroNew;

    // Calculate the rotation remaining
    degreesToGo =  abs(turnDegrees) - abs(Angle);

    // motor speed is proportional to the amount of rotation remaining
    motorSpeed = (int)(DegreeGain * abs(degreesToGo));

    // limit the motor speed to be greater than 15 and less than 75
    if (abs(motorSpeed) > MAX_GYRO_SPEED) motorSpeed = MAX_GYRO_SPEED;
    if (abs(motorSpeed) < MIN_GYRO_SPEED) motorSpeed = MIN_GYRO_SPEED;

    motor[B_L] = rotDirection * motorSpeed ; // looking from the top, left side moves back, right
    motor[B_R] = -rotDirection * motorSpeed ; // side moves forward for (+) CCW rotation

    if( time100[T3] > 50 ) break; // if the bot is not done turning in 5 sec, quit
    wait1Msec(15); // wait 20 ms to allow a reasonable period for the integration

  } // End while rotation remaining

  // since we have now reached the target rotation (the while loop is done), stop all drive motors

  motor[B_R] = 0;
  motor[B_L] = 0;

  // reset the back motor encoders to zero
  nMotorEncoder[B_R] = 0;
  nMotorEncoder[B_L] = 0;

} // End of Turn_Gyro()



/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	//waitForStart(); // Wait for the beginning of autonomous phase.
	//int IRvalue = SensorValue[IR];
	wait10Msec(140);

	int IRvalue = 7;

	if(IRvalue < 5 || IRvalue > 7)
	{
		IRvalue = 0;
	}
//Robot takes reading of the IR


	if(IRvalue==5)//Far
	{
		wait10Msec(25);

		Move(80,75);
		wait10Msec(55);

		Turn(300);
		wait10Msec(55);

		Move(20,75);
		wait10Msec(55);

		Turn(90);
		wait10Msec(55);
	}

	if(IRvalue==6 || IRvalue==0)//Middle
	{
    wait10Msec(25);

		Move(80,75);
		wait10Msec(55);

		Turn(300);
		wait10Msec(55);

		Move(26,75);
		wait10Msec(55);

		Turn(90);
		wait10Msec(55);
	}

	if(IRvalue==7)//Close
	{
		wait10Msec(25);

		Move(80,75);
		wait10Msec(55);
		/*

		Turn(300);
		wait10Msec(55);

		Move(32,75);
		wait10Msec(55);

		Turn(90);
		wait10Msec(55);*/
	}

	if(IRvalue==8)//Closest
	{
		wait10Msec(25);

		Move(80,75);
		wait10Msec(55);

		Turn(300);
		wait10Msec(55);

		Move(38,75);
		wait10Msec(55);

		Turn(90);
		wait10Msec(55);
  }
}
