#pragma config(Sensor, S1,     ,               sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "common.h"
#define clock 0x02 //B1
#define data 0x01 //B0
bool scl = false;
bool sda = false;
byte buffer[10];

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

//General I2C Communication Functions
/***************************************************************/
void writeLines()
{
	scl = !scl;
	sda = !sda;
	tByteArray msg;
	msg[0] = 3;
	msg[1] = 0x10;
	msg[2] = 0x4E;
	msg[3] = (scl && sda) ? (clock + data) : (scl ? clock : (sda ? data : 0x00));
	writeI2C(S1, msg);

	scl = !scl;
	sda = !sda;
	msg[2] = 0x4D;
	msg[3] = (scl && sda) ? (clock + data) : (scl ? clock : (sda ? data : 0x00));
	writeI2C(S1, msg);
}
void clockHi()
{
	scl = true;
	writeLines();
}
void clockLo()
{
	scl = false;
	writeLines();
}
bool checkClock()
{
	tByteArray msg;
	msg[0] = 2;
	msg[1] = 0x10;
	msg[2] = 0x4C;
	tByteArray reply;
	writeI2C(S1, msg, reply, 1);
	if ((reply[0] & clock) > 0)
		return true;
	else
		return false;
}
void dataHi()
{
	sda = true;
	writeLines();
}
void dataLo()
{
	sda = false;
	writeLines();
}
bool checkData()
{
	tByteArray msg;
	msg[0] = 2;
	msg[1] = 0x10;
	msg[2] = 0x4C;
	tByteArray reply;
	writeI2C(S1, msg, reply, 1);
	writeDebugStreamLine("%d", (reply[0] & data) > 0);
	if ((reply[0] & data) > 0)
		return true;
	else
		return false;
}
void delay()
{
	int _random = 0;
	for (int i = 0; i <= 5; i++)
		_random += 1;
}
void i2cStart()
{
	dataHi();
	delay();
	clockHi();
	delay();
	dataLo();
	delay();
	clockLo();
	delay();
}
void i2cStop()
{
	clockLo();
	delay();
	dataLo();
	delay();
	clockHi();
	delay();
	dataHi();
	delay();
}
void i2cTx(ubyte d)
{
	for (int x = 8; x > 0; x--)
	{
		if (d & 0x80)
			dataHi();
		else
			dataLo();
		delay();
		clockHi();
		d <<= 1;
		clockLo();
	}
	delay();
	dataHi();
	clockHi();
	while (!checkClock()){}
	//Ack comes here
	delay();
	clockLo();
}
void writeData(ubyte a, ubyte iA, ubyte d)
{
	a <<= 1;
	i2cStart();
	i2cTx(a);
	i2cTx(iA);
	i2cTx(d);
	i2cStop();
}
byte i2cRx(bool ack)
{
	ubyte d = 0;
	dataHi();
	for(int x = 0; x < 8; x++)
	{
		d <<= 1;
		clockHi();
		while(!checkClock()){}
		delay();
		bool t = checkData();
		d |= (int)t;
		writeDebugStreamLine("%d", t);
		clockLo();
	}
	if (ack)
		dataLo();
	else
		dataHi();
	clockHi();
	delay();
	clockLo();
	dataHi();
	return d;
}
void readData(ubyte a, ubyte iA, int bytesToRead)
{
	a <<= 1;
	i2cStart();
	i2cTx(a);
	i2cTx(iA);
	i2cStart();
	i2cTx(a + 1);
	int last = 0;
	for (int i = 0; i < bytesToRead - 1; i++)
	{
		buffer[i] = i2cRx(true);
		last = i + 1;
	}
	buffer[last] = i2cRx(false);
	i2cStop();
}
/***************************************************************/

//Sensor Specific Functions
#define accelAddr 0x53
#define powerCtrlAddr 0x2D
#define dataFormatAddr 0x31
#define xAddr0 0x32
#define yAddr0 0x34
#define zAddr0 0x36

void setupAccel()
{
	writeData(accelAddr, dataFormatAddr, 0x01);
	writeData(accelAddr, dataFormatAddr, 0x08);
}

int xAccel = 0.0;
int yAccel = 0.0;
int zAccel = 0.0;
void updateAcceleration()
{
	readData(accelAddr, xAddr0, 6);
	xAccel = (((int)buffer[0]) << 8) | buffer[1];
	yAccel = (((int)buffer[2]) << 8) | buffer[3];
	zAccel = (((int)buffer[4]) << 8) | buffer[5];
}

task main()
{
	initializeRobot();

	//waitForStart(); // Wait for the beginning of autonomous phase.
	clearDebugStream();
	//setupProtoBoard();
	setupAccel();
	bool t = false;
	while (true)
	{
		updateAcceleration();
		writeDebugStreamLine("X Accel: %f", xAccel);

	}
}
